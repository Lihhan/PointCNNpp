<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>PointCNN++: Performant Convolution on Native Points</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root{
--bg: #fafafa;
--surface: #ffffff;
--card: #ffffff;
--text: #2c3e50;
--text-muted: #5a6c7d;
--text-dim: #7f8c8d;
--accent: #3498db;
--accent-soft: #5dade2;
--shadow: 0 2px 10px rgba(0,0,0,0.1);
--shadow-hover: 0 4px 20px rgba(0,0,0,0.15);
--header-bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

*{box-sizing:border-box;}

body{
margin:0;
background:var(--bg);
color:var(--text);
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
line-height:1.6;
overflow-x:hidden;
}

/* Hero Section */
.hero {
position: relative;
padding: 6rem 2rem 4rem 2rem;
background: white;
text-align: center;
color: var(--text);
margin-top: 2rem;
}

.hero h1 {
margin: 0 0 1.5rem 0;
font-size: clamp(2rem, 4vw, 3rem);
font-weight: 700;
letter-spacing: -0.02em;
color: var(--text);
}

.hero .subtitle {
font-size: 1.2rem;
font-weight: 300;
margin: 1rem 0 2rem 0;
max-width: 800px;
margin-left: auto;
margin-right: auto;
color: var(--text-muted);
}

.authors {
font-size: 1.1rem;
margin: 1.5rem 0;
font-weight: 500;
color: var(--text);
}

.authors sup, .affiliations sup {
font-size: 0.75em;
vertical-align: super;
}

.affiliations {
font-size: 0.95rem;
margin-top: 1rem;
margin-bottom: 3rem;
color: var(--text-muted);
line-height: 1.4;
}

.hero-buttons {
margin-top: 3rem;
display: flex;
justify-content: center;
gap: 1rem;
flex-wrap: wrap;
}

.btn {
padding: 0.75rem 1.5rem;
background: var(--accent);
color: white;
text-decoration: none;
border-radius: 8px;
font-weight: 500;
transition: all 0.3s ease;
border: 1px solid var(--accent);
display: inline-block;
}

.btn:hover {
background: var(--accent-soft);
transform: translateY(-2px);
}

/* Main content */
.container {
max-width: 1200px;
margin: 0 auto;
padding: 0 2rem;
}

section {
margin: 3rem 0;
}

h2 {
font-size: 2rem;
text-align: center;
margin-bottom: 2rem;
color: var(--text);
font-weight: 600;
}

.abstract {
background: var(--surface);
padding: 2.5rem;
border-radius: 12px;
box-shadow: var(--shadow);
margin: 2rem 0;
text-align: center;
}

.abstract p {
font-size: 1.1rem;
line-height: 1.8;
max-width: 900px;
margin: 0 auto;
}

/* Overview Section */
.overview-intro {
text-align: center;
margin-bottom: 3rem;
font-size: 1.1rem;
color: var(--text-muted);
max-width: 800px;
margin-left: auto;
margin-right: auto;
}

.overview-components {
display: flex;
flex-direction: column;
gap: 3rem;
}

.component-card {
background: white;
border-radius: 12px;
padding: 2rem;
box-shadow: 0 4px 20px rgba(0,0,0,0.1);
border: 1px solid rgba(44,62,80,0.1);
}

.component-card h3 {
color: var(--accent);
margin-bottom: 1.5rem;
font-size: 1.5rem;
text-align: center;
font-weight: 600;
}

.component-content {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 2rem;
align-items: center;
}

.component-image {
text-align: center;
}

.component-image canvas {
border-radius: 8px;
background: white;
border: 1px solid rgba(44,62,80,0.1);
}

.image-caption {
font-size: 0.9rem;
color: var(--text-muted);
font-style: italic;
margin-top: 0.5rem;
}

.component-description {
font-size: 1rem;
line-height: 1.6;
color: var(--text);
}

.overview-section {
background: var(--surface);
padding: 2.5rem;
border-radius: 12px;
box-shadow: var(--shadow);
margin: 2rem 0;
}

/* Performance section */
.performance-section {
background: var(--surface);
padding: 2.5rem;
border-radius: 12px;
box-shadow: var(--shadow);
margin: 2rem 0;
}

.toggle {
display: flex;
justify-content: center;
gap: 1rem;
margin: 2rem 0;
}

.toggle button {
background: #f1f3f4;
border: none;
color: var(--text-muted);
padding: 0.75rem 1.5rem;
border-radius: 8px;
font-weight: 500;
cursor: pointer;
transition: all 0.3s;
}

.toggle button:hover {
background: #e8eaed;
color: var(--text);
}

.toggle button.active {
background: var(--accent);
color: white;
}

.charts {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
gap: 2rem;
margin-top: 2rem;
}

.chart-container {
background: #f8f9fa;
border-radius: 12px;
padding: 1.5rem;
min-height: 400px;
box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

/* Results table */
.results-section {
background: var(--surface);
padding: 2.5rem;
border-radius: 12px;
box-shadow: var(--shadow);
margin: 2rem 0;
}

.results-card {
background: #f8f9fa;
border-radius: 12px;
padding: 2rem;
margin-bottom: 2rem;
overflow-x: auto;
}

.results-table {
width: 100%;
border-collapse: collapse;
font-size: 0.9rem;
margin: 1rem 0;
background: white;
border-radius: 8px;
overflow: hidden;
}

.results-table th {
background: var(--accent);
color: white;
padding: 1rem;
text-align: center;
font-weight: 600;
}

.results-table td {
padding: 0.75rem;
text-align: center;
border-bottom: 1px solid #e9ecef;
}

.results-table tbody tr:hover {
background: #f1f3f4;
}

.best {
color: #e74c3c;
font-weight: 700;
}

.second-best {
color: #3498db;
font-weight: 700;
}

.method-name {
text-align: left !important;
font-weight: 600;
}

.method-description {
text-align: center;
font-size: 1rem;
color: var(--text-muted);
margin: 1rem 0;
}

/* Responsive design */
@media (max-width: 768px) {
.hero h1 {
font-size: 1.8rem;
}

.component-content {
grid-template-columns: 1fr;
gap: 1.5rem;
}

.component-card {
padding: 1.5rem;
}

.charts {
grid-template-columns: 1fr;
}

.toggle {
flex-direction: column;
align-items: center;
}

.toggle button {
width: 200px;
}

.hero-buttons {
flex-direction: column;
align-items: center;
}

.btn {
width: 200px;
text-align: center;
}
}

/* Animation */
.fade-in {
animation: fadeInUp 0.8s ease forwards;
opacity: 0;
transform: translateY(20px);
}

@keyframes fadeInUp {
to {
opacity: 1;
transform: translateY(0);
}
}
</style>
</head>
<body>

<!-- Hero Section -->
<div class="hero">
<h1>PointCNN++: Performant Convolution on Native Points</h1>
<p class="subtitle">A novel 3D point cloud convolution architecture that achieves significantly higher memory efficiency and processing speed while preserving geometric detail and high fidelity.</p>

<div class="authors">
    Lihan Li<sup>1*</sup>, Haofeng Zhong<sup>1*</sup>, Rui Bu<sup>2</sup>, Mingchao Sun<sup>3</sup>,<br>
    Wenzheng Chen<sup>1†</sup>, Baoquan Chen<sup>1†</sup>, Yangyan Li<sup>2†</sup>
</div>

<div class="affiliations">
    <sup>1</sup>Peking University &nbsp;&nbsp; 
    <sup>2</sup>Ant Group &nbsp;&nbsp; 
    <sup>3</sup>AMAP<br>
    <span style="font-size: 0.85rem; margin-top: 0.5rem; display: block;">
        *Equal contributions, †Corresponding author
    </span>
</div>

<div class="hero-buttons">
<a href="https://www.arxiv.org/abs/2511.23227" class="btn">Paper</a>
<a href="#" class="btn">Code (Coming Soon)</a>
</div>
</div>

<!-- Abstract -->
<div class="container">
<section class="fade-in">
<div class="abstract">
<h2>Abstract</h2>
<p>
Existing 3D point cloud methods face a precision-performance trade-off: point-based methods preserve geometric detail but are slow, while voxel-based methods are fast but lose precision. We propose PointCNN++, which generalizes sparse convolution from voxels to points, treating voxel-based convolution as a special case of our more general point-based approach. Our method introduces point-centric convolution centered on high-precision coordinates and formulates the operation as a Matrix-Vector Multiplication and Reduction (MVMR) problem with a dedicated GPU kernel. PointCNN++ achieves an order of magnitude less memory usage and several times faster speed than point-based methods, while significantly improving registration accuracy compared to voxel-based approaches, demonstrating that high fidelity and efficiency are not mutually exclusive.</div>
</section>

<!-- Overview -->
<section class="fade-in">
<div class="overview-section">
<h2>Overview</h2>

<!-- 整体方法描述 -->
<div class="overview-intro">
<p>PointCNN++ introduces a key optimization in convolution computation that fundamentally addresses the Performance bottleneck in 3D point cloud processing:</p>
</div>

<div class="overview-components">
<div class="component-card">
<h3>Efficient GPU Algorithm of MVMR</h3>
<div class="component-content">
<div class="component-image" style="text-align: center;">
<img src="teaser.png" alt="MVMR Optimization Method" style="max-width: 80%; height: auto; transform: scale(1.2);">
</div>
<div class="component-description">
<p>The optimization method sorts and groups triplets by their k values, enabling triplets with the same k to share weight matrix W reads from global memory, thereby reducing memory access complexity from O(|T|) to O(|T|/L) where L is the average group length, significantly improving GPU memory efficiency and reducing computational overhead.</p>
</div>
</div>
</div>
</div>
</section>

<!-- Performance Comparison -->
<section class="fade-in">
<div class="performance-section">
<h2>Performance Comparison</h2>

<div class="toggle">
    <button id="btnRes" class="active">ResNet-18 Backbone</button>
    <button id="btnSingle">Single Convolution Layer</button>
</div>

<div style="text-align: center; margin: 15px 0; color: #666; font-size: 14px;">
    Execution time and memory usage measured on S3DIS dataset
</div>

<!-- ResNet-18 原来的2个柱状图 -->
<div id="resnetCharts">
    <div class="charts-resnet">
        <div class="chart-container">
            <div class="chart-title">ResNet-18 Execution Time Comparison</div>
            <canvas id="timeChart"></canvas>
        </div>
        <div class="chart-container">
            <div class="chart-title">ResNet-18 Memory Usage Comparison</div>
            <canvas id="memChart"></canvas>
        </div>
    </div>
</div>

<!-- Single Convolution的4张图 -->
<div id="singleCharts" style="display:none">
    <div class="charts">
        <div class="chart-container">
            <div class="chart-title">Inference Mode - Memory Usage</div>
            <canvas id="singleMemInf"></canvas>
        </div>
        <div class="chart-container">
            <div class="chart-title">Training Mode - Memory Usage</div>
            <canvas id="singleMemTrain"></canvas>
        </div>
        <div class="chart-container">
            <div class="chart-title">Inference Mode - Time</div>
            <canvas id="singleTimeInf"></canvas>
        </div>
        <div class="chart-container">
            <div class="chart-title">Back-Propagation Part - Time</div>
            <canvas id="singleTimeBack"></canvas>
        </div>
    </div>
</div>

<style>
.toggle {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    justify-content: center;
}

.toggle button {
    padding: 10px 20px;
    border: 2px solid #007bff;
    background: white;
    color: #007bff;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
}

.toggle button.active {
    background: #007bff;
    color: white;
}

/* ResNet图表布局 - 2个图横向排列 */
.charts-resnet {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
    margin: 20px 0;
}

/* Single图表布局 - 4个图2x2排列 */
.charts {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 30px;
    margin: 20px 0;
}

.chart-container {
    position: relative;
    height: 400px;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 20px;
    background: white;
}

.chart-title {
    text-align: center;
    font-weight: bold;
    margin-bottom: 15px;
    font-size: 16px;
    color: #333;
}

/* 淡入效果 */
.fade-in {
  animation: fadeIn 1s ease-in-out both;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}
</style>

</div>

<script>
// Chart.js defaults
Chart.defaults.color = '#2c3e50';
Chart.defaults.borderColor = 'rgba(44,62,80,0.1)';

// Toggle functionality
document.addEventListener('DOMContentLoaded', function() {
    const btnRes = document.getElementById('btnRes');
    const btnSingle = document.getElementById('btnSingle');
    const resDiv = document.getElementById('resnetCharts');
    const singleDiv = document.getElementById('singleCharts');

    if (btnRes && btnSingle && resDiv && singleDiv) {
        btnRes.onclick = () => {
            btnRes.classList.add('active');
            btnSingle.classList.remove('active');
            resDiv.style.display = 'block';
            singleDiv.style.display = 'none';
        };

        btnSingle.onclick = () => {
            btnSingle.classList.add('active');
            btnRes.classList.remove('active');
            resDiv.style.display = 'none';
            singleDiv.style.display = 'block';
        };
    }

    // Initialize charts after DOM is loaded
    initializeAllCharts();
});

function initializeAllCharts() {
    // ===== ResNet-18 backbone charts (原来的2个柱状图) =====
    const resnetMethods = ['KPConv','O-CNN','MinkowskiEng.','TorchSparse++','SPConv','fVDB','Ours (deg.)','Ours'];
    const fwd = [3316.6,199.3,78.3,83.7,62.8,49.6,60.4,51.5];
    const bwd = [6331.1,351.1,212.3,152.1,133.9,105.6,71.5,67.0];

    // ResNet time chart
    if (document.getElementById('timeChart')) {
        new Chart('timeChart', {
            type: 'bar',
            data: {
                labels: resnetMethods,
                datasets: [
                    {label: 'Forward (ms)', data: fwd, backgroundColor: '#bdc3c7', borderColor: '#95a5a6', borderWidth: 1},
                    {label: 'Backward (ms)', data: bwd, backgroundColor: '#e74c3c', borderColor: '#c0392b', borderWidth: 1}
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {position: 'top', labels: {color: '#2c3e50'}}
                },
                scales: {
                    y: {
                        type: 'logarithmic',
                        min: 10,
                        max: 10000,
                        title: {display: true, text: 'Time (ms)', color: '#2c3e50'},
                        grid: {color: 'rgba(44,62,80,0.1)'},
                        ticks: {color: '#2c3e50'}
                    },
                    x: {
                        grid: {color: 'rgba(44,62,80,0.05)'},
                        ticks: {color: '#2c3e50'}
                    }
                }
            }
        });
    }

    // ResNet memory chart
    const memLabels = ['O-CNN','KPConv','TorchSparse++','SPConv','MinkowskiEng.','fVDB','Ours (deg.)','Ours'];
    const infM = [10.93,4.64,3.08,2.64,1.20,0.72,0.38,0.37];
    const backM = [11.61,8.24,3.08,2.64,1.20,1.79,0.59,0.55];

    if (document.getElementById('memChart')) {
        new Chart('memChart', {
            type: 'bar',
            data: {
                labels: memLabels,
                datasets: [
                    {label: 'Inference (GB)', data: infM, backgroundColor: '#85c1e9', borderColor: '#5dade2', borderWidth: 1},
                    {label: 'Training (GB)', data: backM, backgroundColor: '#bdc3c7', borderColor: '#95a5a6', borderWidth: 1}
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {position: 'top', labels: {color: '#2c3e50'}}
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {display: true, text: 'Peak Memory (GB)', color: '#2c3e50'},
                        grid: {color: 'rgba(44,62,80,0.1)'},
                        ticks: {color: '#2c3e50'}
                    },
                    x: {
                        grid: {color: 'rgba(44,62,80,0.05)'},
                        ticks: {color: '#2c3e50'}
                    }
                }
            }
        });
    }

    // ===== Single convolution layer charts (4张图) =====
    const singleMethods = ['KPConv', 'O-CNN', 'Minkowski', 'TorchSparse++', 'SPConv', 'fVDB', 'Ours (deg.)', 'Ours'];
    const singleColors = ['#8B5CF6','#10B981','#3B82F6','#FF6B35','#8B5A2B','#F59E0B','#06B6D4','#DC2626'];
    
    // 平均数据
    const avgMemInf = [12.71, 3.83, 2.24, 1.39, 3.94, 2.59, 1.19, 1.16];
    const avgMemTrain = [19.15, 4.67, 2.87, 1.89, 6.47, 3.22, 1.20, 1.17];
    const avgTimeInf = [896.49, 112.13, 46.70, 26.25, 19.75, 34.64, 17.35, 18.06];
    const avgTimeBack = [168.69, 241.28, 116.55, 34.54, 74.40, 54.45, 31.17, 29.65];

    // Single Memory Inference
    if (document.getElementById('singleMemInf')) {
        new Chart('singleMemInf', {
            type: 'bar',
            data: {
                labels: singleMethods,
                datasets: [{
                    label: 'Memory (GB)',
                    data: avgMemInf,
                    backgroundColor: singleColors.map(c => c + '80'),
                    borderColor: singleColors,
                    borderWidth: 2
                }]
            },
            options: getChartOptions('Memory (GB)', false)
        });
    }

    // Single Memory Training
    if (document.getElementById('singleMemTrain')) {
        new Chart('singleMemTrain', {
            type: 'bar',
            data: {
                labels: singleMethods,
                datasets: [{
                    label: 'Memory (GB)',
                    data: avgMemTrain,
                    backgroundColor: singleColors.map(c => c + '80'),
                    borderColor: singleColors,
                    borderWidth: 2
                }]
            },
            options: getChartOptions('Memory (GB)', false)
        });
    }

    // Single Time Inference
    if (document.getElementById('singleTimeInf')) {
        new Chart('singleTimeInf', {
            type: 'bar',
            data: {
                labels: singleMethods,
                datasets: [{
                    label: 'Time (ms)',
                    data: avgTimeInf,
                    backgroundColor: singleColors.map(c => c + '80'),
                    borderColor: singleColors,
                    borderWidth: 2
                }]
            },
            options: getChartOptions('Time (ms)', true)
        });
    }

    // Single Time Backward
    if (document.getElementById('singleTimeBack')) {
        new Chart('singleTimeBack', {
            type: 'bar',
            data: {
                labels: singleMethods,
                datasets: [{
                    label: 'Time (ms)',
                    data: avgTimeBack,
                    backgroundColor: singleColors.map(c => c + '80'),
                    borderColor: singleColors,
                    borderWidth: 2
                }]
            },
            options: getChartOptions('Time (ms)', true)
        });
    }
}

// 通用图表配置函数
function getChartOptions(yLabel, isLogarithmic) {
    return {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {display: false}
        },
        scales: {
            y: {
                type: isLogarithmic ? 'logarithmic' : 'linear',
                beginAtZero: !isLogarithmic,
                min: isLogarithmic ? 10 : undefined,
                title: {display: true, text: yLabel, color: '#2c3e50'},
                grid: {color: 'rgba(44,62,80,0.1)'},
                ticks: {color: '#2c3e50'}
            },
            x: {
                grid: {color: 'rgba(44,62,80,0.05)'},
                ticks: {color: '#2c3e50', maxRotation: 45}
            }
        }
    };
}

// Fade in animation observer
const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.classList.add('fade-in');
        }
    });
});

document.querySelectorAll('section').forEach(el => observer.observe(el));
</script>

</section>
    
</body>
</html>
